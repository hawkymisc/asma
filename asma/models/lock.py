"""Lock file models for tracking installed skills."""
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Tuple
import yaml

from asma.models.skill import SkillScope


@dataclass
class LockEntry:
    """Represents a locked skill version."""

    name: str
    scope: SkillScope
    source: str

    resolved_version: str  # Tag or "main@commit" or "local@checksum"
    resolved_commit: str   # Full SHA or checksum
    installed_at: datetime
    checksum: str          # SHA256 of SKILL.md

    # Optional fields
    symlink: bool = False
    resolved_path: Optional[str] = None  # For local sources

    def to_dict(self) -> Dict[str, any]:
        """Convert lock entry to dictionary for serialization."""
        data = {
            "source": self.source,
            "resolved_version": self.resolved_version,
            "resolved_commit": self.resolved_commit,
            "installed_at": self.installed_at.isoformat(),
            "checksum": self.checksum,
        }

        if self.symlink:
            data["symlink"] = self.symlink
        if self.resolved_path:
            data["resolved_path"] = self.resolved_path

        return data

    @classmethod
    def from_dict(cls, name: str, scope: SkillScope, data: Dict[str, any]) -> "LockEntry":
        """Create lock entry from dictionary."""
        return cls(
            name=name,
            scope=scope,
            source=data["source"],
            resolved_version=data["resolved_version"],
            resolved_commit=data["resolved_commit"],
            installed_at=datetime.fromisoformat(data["installed_at"]),
            checksum=data["checksum"],
            symlink=data.get("symlink", False),
            resolved_path=data.get("resolved_path")
        )


class Lockfile:
    """Manages skillset.lock file."""

    def __init__(self) -> None:
        """Initialize an empty lockfile."""
        self.version: int = 1
        self.generated_at: datetime = datetime.now()
        self.skills: Dict[Tuple[str, SkillScope], LockEntry] = {}

    def add_entry(self, entry: LockEntry) -> None:
        """Add or update a lock entry."""
        key = (entry.name, entry.scope)
        self.skills[key] = entry

    def get_entry(self, name: str, scope: SkillScope) -> Optional[LockEntry]:
        """Get a lock entry by name and scope."""
        key = (name, scope)
        return self.skills.get(key)

    def remove_entry(self, name: str, scope: SkillScope) -> None:
        """Remove a lock entry."""
        key = (name, scope)
        if key in self.skills:
            del self.skills[key]

    def save(self, path: Path) -> None:
        """Save lockfile to disk."""
        # Build lockfile structure
        lock_data = {
            "version": self.version,
            "generated_at": self.generated_at.isoformat(),
            "skills": {
                "global": {},
                "project": {}
            }
        }

        # Add entries grouped by scope
        for (name, scope), entry in self.skills.items():
            scope_key = scope.value  # "global" or "project"
            lock_data["skills"][scope_key][name] = entry.to_dict()

        # Write to file
        with open(path, 'w') as f:
            f.write("# Auto-generated by asma - do not edit manually\n")
            f.write("# This file locks installed skill versions for reproducibility\n\n")
            yaml.safe_dump(lock_data, f, default_flow_style=False, sort_keys=False)

    @classmethod
    def load(cls, path: Path) -> "Lockfile":
        """Load lockfile from disk."""
        if not path.exists():
            return cls()

        with open(path, 'r') as f:
            data = yaml.safe_load(f)

        if not data:
            return cls()

        lockfile = cls()
        lockfile.version = data.get("version", 1)

        # Parse generated_at
        if "generated_at" in data:
            lockfile.generated_at = datetime.fromisoformat(data["generated_at"])

        # Load skills
        skills_data = data.get("skills", {})

        # Load global skills
        for name, entry_data in skills_data.get("global", {}).items():
            entry = LockEntry.from_dict(name, SkillScope.GLOBAL, entry_data)
            lockfile.add_entry(entry)

        # Load project skills
        for name, entry_data in skills_data.get("project", {}).items():
            entry = LockEntry.from_dict(name, SkillScope.PROJECT, entry_data)
            lockfile.add_entry(entry)

        return lockfile
